{-|
    Daniel Moesgaard Andersen
    20164256
    dand16@student.aau.dk
-}

-- Using data.List to access a the sortOn function, used in countLetters.
import Data.List (sortOn)

-- Custom datatypes to make the code easier to read
type Symbol = Char
type Weight = Int

-- The tree structure
data Tree = Leaf Symbol Weight
            | Branch Tree Tree [Symbol] Weight
                deriving (Show)

{-|
    The countLetter function is used to generate a list of tuples, describing
    how many times a given letter occurs. This set of tuples is then sorted based on weight and
    converted to a list of type Leaf.
-}
countLetters :: [Symbol] -> [Tree]
countLetters [] = []
countLetters inputString = makeLeaf (sortOn snd [(x, y) | x<-[' '..'z'], let y = (length.filter (==x)) inputString, y>0])

{-|
    makeLeaf is a helper function for turning a tuple of type [(Char, Int)] into a leaf, so that it
    can be used in the other functions that take a tree as input.
-}
makeLeaf :: [(Char, Int)] -> [Tree]
makeLeaf [] = []
makeLeaf (x:xs) = Leaf (fst x) (snd x) : makeLeaf xs

{-|
    makeBranch is a helper function for combining two Leafs into a branch, by
    concatenating the two symbol lists and adding their weight.
-}
makeBranch :: Tree -> Tree -> Tree
makeBranch left right       = Branch left right
                                ((getSymbol left) ++ (getSymbol right))
                                ((getWeight left) + (getWeight right))

{-|
    getWeight is a function to access the weight of a tree type.
-}
getWeight :: Tree -> Weight
getWeight (Leaf _ w) = w
getWeight (Branch _ _ _ w) = w

{-|
    getSymbol is a function to access the weight of a tree type.
-}
getSymbol :: Tree -> [Symbol]
getSymbol (Leaf s _) = [s]
getSymbol (Branch _ _ s _) = s

{-|
    sortedInsert is used as a helper for makeEncodingTree to correctly insert a
    branch into the list, based on its weight.
-}
sortedInsert :: Tree -> [Tree] -> [Tree]
sortedInsert n [] = [n]
sortedInsert n (x:xs) = if (getWeight n) <= (getWeight x)
                        then n:x:xs
                        else x: sortedInsert n xs

{-|
    makeEncodingTree is the function used for generating an encoding tree that can
    be passed to encode and decode. It takes a list of leaves as input, that are generated by
    the countLetters function.
-}
makeEncodingTree :: [Tree] -> Tree
makeEncodingTree [n] = n
makeEncodingTree (left:right:rest) =
    let branch = makeBranch left right
    in makeEncodingTree (sortedInsert branch rest)

{-|
    encode is used to encode a message, it takes a string and an encoding tree (generated by makeEncodingTree)
    as input, and outputs a list of integers, describing a path in the given tree.
-}
encode :: [Symbol] -> Tree -> [Int]
encode [] _ = []
encode symbol tree = encode' tree tree symbol -- Call a helper method that takes tree

{-|
    encode' is a helper function for encoding, that takes an additional tree as input, such that
    when it arrives at a leaf, it still has the original encoding tree, and is able to return to
    root and continue encoding with the next symbol in the input string.
-}
encode' :: Tree -> Tree -> [Symbol] -> [Int]
encode' _ _ [] = []
encode' encodingTree (Leaf _ _) (_:xs) = encode' encodingTree encodingTree xs
encode' encodingTree (Branch left right _ _) (x:xs) =
        if elem x (getSymbol left)  then    0 : encode' encodingTree left (x:xs) -- If x exists in first branch, go there and send current and next letters along
        else                                1 : encode' encodingTree right (x:xs) -- otherwise go to the other branch

{-|
    decode is used to decode a message, it takes a list of integers and an encoding tree (generated by makeEncodingTree)
    as input, and outputs the decoded message.
-}
decode :: [Int] -> Tree -> [Symbol]
decode [] _ = []
decode symbol tree = decode' tree tree symbol

{-|
    decode' is a helper method for decode that takes an additional encoding tree as input,
    so that it still has the original encoding tree after reaching a leaf, and is able to
    return to the root and continue decoding.
-}
decode' :: Tree -> Tree -> [Int] -> [Symbol]
decode' decodingTree (Leaf symbol _ ) path  = symbol : decode' decodingTree decodingTree path
decode' decodingTree (Branch left right _ _) (bit:path)  =
        if (bit == 0) then  decode' decodingTree left path
        else                decode' decodingTree right path
decode' _ _ [] = []
